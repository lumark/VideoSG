// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: segmentation.proto

#ifndef PROTOBUF_segmentation_2eproto__INCLUDED
#define PROTOBUF_segmentation_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace segmentation {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_segmentation_2eproto();
void protobuf_AssignDesc_segmentation_2eproto();
void protobuf_ShutdownFile_segmentation_2eproto();

class RegionFeatures;
class SegmentationDesc;
class SegmentationDesc_Rasterization;
class SegmentationDesc_Rasterization_ScanInterval;
class SegmentationDesc_ShapeMoments;
class SegmentationDesc_VectorMesh;
class SegmentationDesc_Polygon;
class SegmentationDesc_Vectorization;
class SegmentationDesc_Region2D;
class SegmentationDesc_CompoundRegion;
class SegmentationDesc_HierarchyLevel;
class AppearanceFeature;
class FlowFeature;
class TextureFeature;

enum SegmentationDesc_Connectedness {
  SegmentationDesc_Connectedness_N4_CONNECT = 1,
  SegmentationDesc_Connectedness_N8_CONNECT = 2
};
bool SegmentationDesc_Connectedness_IsValid(int value);
const SegmentationDesc_Connectedness SegmentationDesc_Connectedness_Connectedness_MIN = SegmentationDesc_Connectedness_N4_CONNECT;
const SegmentationDesc_Connectedness SegmentationDesc_Connectedness_Connectedness_MAX = SegmentationDesc_Connectedness_N8_CONNECT;
const int SegmentationDesc_Connectedness_Connectedness_ARRAYSIZE = SegmentationDesc_Connectedness_Connectedness_MAX + 1;

const ::google::protobuf::EnumDescriptor* SegmentationDesc_Connectedness_descriptor();
inline const ::std::string& SegmentationDesc_Connectedness_Name(SegmentationDesc_Connectedness value) {
  return ::google::protobuf::internal::NameOfEnum(
    SegmentationDesc_Connectedness_descriptor(), value);
}
inline bool SegmentationDesc_Connectedness_Parse(
    const ::std::string& name, SegmentationDesc_Connectedness* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SegmentationDesc_Connectedness>(
    SegmentationDesc_Connectedness_descriptor(), name, value);
}
// ===================================================================

class RegionFeatures : public ::google::protobuf::Message {
 public:
  RegionFeatures();
  virtual ~RegionFeatures();

  RegionFeatures(const RegionFeatures& from);

  inline RegionFeatures& operator=(const RegionFeatures& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegionFeatures& default_instance();

  void Swap(RegionFeatures* other);

  // implements Message ----------------------------------------------

  RegionFeatures* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegionFeatures& from);
  void MergeFrom(const RegionFeatures& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(RegionFeatures)
  // @@protoc_insertion_point(class_scope:segmentation.RegionFeatures)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_segmentation_2eproto();
  friend void protobuf_AssignDesc_segmentation_2eproto();
  friend void protobuf_ShutdownFile_segmentation_2eproto();

  void InitAsDefaultInstance();
  static RegionFeatures* default_instance_;
};
// -------------------------------------------------------------------

class SegmentationDesc_Rasterization_ScanInterval : public ::google::protobuf::Message {
 public:
  SegmentationDesc_Rasterization_ScanInterval();
  virtual ~SegmentationDesc_Rasterization_ScanInterval();

  SegmentationDesc_Rasterization_ScanInterval(const SegmentationDesc_Rasterization_ScanInterval& from);

  inline SegmentationDesc_Rasterization_ScanInterval& operator=(const SegmentationDesc_Rasterization_ScanInterval& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SegmentationDesc_Rasterization_ScanInterval& default_instance();

  void Swap(SegmentationDesc_Rasterization_ScanInterval* other);

  // implements Message ----------------------------------------------

  SegmentationDesc_Rasterization_ScanInterval* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SegmentationDesc_Rasterization_ScanInterval& from);
  void MergeFrom(const SegmentationDesc_Rasterization_ScanInterval& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 y = 1;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 1;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // required int32 left_x = 2;
  inline bool has_left_x() const;
  inline void clear_left_x();
  static const int kLeftXFieldNumber = 2;
  inline ::google::protobuf::int32 left_x() const;
  inline void set_left_x(::google::protobuf::int32 value);

  // required int32 right_x = 3;
  inline bool has_right_x() const;
  inline void clear_right_x();
  static const int kRightXFieldNumber = 3;
  inline ::google::protobuf::int32 right_x() const;
  inline void set_right_x(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:segmentation.SegmentationDesc.Rasterization.ScanInterval)
 private:
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_left_x();
  inline void clear_has_left_x();
  inline void set_has_right_x();
  inline void clear_has_right_x();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 left_x_;
  ::google::protobuf::int32 right_x_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_segmentation_2eproto();
  friend void protobuf_AssignDesc_segmentation_2eproto();
  friend void protobuf_ShutdownFile_segmentation_2eproto();

  void InitAsDefaultInstance();
  static SegmentationDesc_Rasterization_ScanInterval* default_instance_;
};
// -------------------------------------------------------------------

class SegmentationDesc_Rasterization : public ::google::protobuf::Message {
 public:
  SegmentationDesc_Rasterization();
  virtual ~SegmentationDesc_Rasterization();

  SegmentationDesc_Rasterization(const SegmentationDesc_Rasterization& from);

  inline SegmentationDesc_Rasterization& operator=(const SegmentationDesc_Rasterization& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SegmentationDesc_Rasterization& default_instance();

  void Swap(SegmentationDesc_Rasterization* other);

  // implements Message ----------------------------------------------

  SegmentationDesc_Rasterization* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SegmentationDesc_Rasterization& from);
  void MergeFrom(const SegmentationDesc_Rasterization& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SegmentationDesc_Rasterization_ScanInterval ScanInterval;

  // accessors -------------------------------------------------------

  // repeated .segmentation.SegmentationDesc.Rasterization.ScanInterval scan_inter = 1;
  inline int scan_inter_size() const;
  inline void clear_scan_inter();
  static const int kScanInterFieldNumber = 1;
  inline const ::segmentation::SegmentationDesc_Rasterization_ScanInterval& scan_inter(int index) const;
  inline ::segmentation::SegmentationDesc_Rasterization_ScanInterval* mutable_scan_inter(int index);
  inline ::segmentation::SegmentationDesc_Rasterization_ScanInterval* add_scan_inter();
  inline const ::google::protobuf::RepeatedPtrField< ::segmentation::SegmentationDesc_Rasterization_ScanInterval >&
      scan_inter() const;
  inline ::google::protobuf::RepeatedPtrField< ::segmentation::SegmentationDesc_Rasterization_ScanInterval >*
      mutable_scan_inter();

  // @@protoc_insertion_point(class_scope:segmentation.SegmentationDesc.Rasterization)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::segmentation::SegmentationDesc_Rasterization_ScanInterval > scan_inter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_segmentation_2eproto();
  friend void protobuf_AssignDesc_segmentation_2eproto();
  friend void protobuf_ShutdownFile_segmentation_2eproto();

  void InitAsDefaultInstance();
  static SegmentationDesc_Rasterization* default_instance_;
};
// -------------------------------------------------------------------

class SegmentationDesc_ShapeMoments : public ::google::protobuf::Message {
 public:
  SegmentationDesc_ShapeMoments();
  virtual ~SegmentationDesc_ShapeMoments();

  SegmentationDesc_ShapeMoments(const SegmentationDesc_ShapeMoments& from);

  inline SegmentationDesc_ShapeMoments& operator=(const SegmentationDesc_ShapeMoments& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SegmentationDesc_ShapeMoments& default_instance();

  void Swap(SegmentationDesc_ShapeMoments* other);

  // implements Message ----------------------------------------------

  SegmentationDesc_ShapeMoments* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SegmentationDesc_ShapeMoments& from);
  void MergeFrom(const SegmentationDesc_ShapeMoments& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float size = 1;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 1;
  inline float size() const;
  inline void set_size(float value);

  // optional float mean_x = 2;
  inline bool has_mean_x() const;
  inline void clear_mean_x();
  static const int kMeanXFieldNumber = 2;
  inline float mean_x() const;
  inline void set_mean_x(float value);

  // optional float mean_y = 3;
  inline bool has_mean_y() const;
  inline void clear_mean_y();
  static const int kMeanYFieldNumber = 3;
  inline float mean_y() const;
  inline void set_mean_y(float value);

  // optional float moment_xx = 4;
  inline bool has_moment_xx() const;
  inline void clear_moment_xx();
  static const int kMomentXxFieldNumber = 4;
  inline float moment_xx() const;
  inline void set_moment_xx(float value);

  // optional float moment_xy = 5;
  inline bool has_moment_xy() const;
  inline void clear_moment_xy();
  static const int kMomentXyFieldNumber = 5;
  inline float moment_xy() const;
  inline void set_moment_xy(float value);

  // optional float moment_yy = 6;
  inline bool has_moment_yy() const;
  inline void clear_moment_yy();
  static const int kMomentYyFieldNumber = 6;
  inline float moment_yy() const;
  inline void set_moment_yy(float value);

  // @@protoc_insertion_point(class_scope:segmentation.SegmentationDesc.ShapeMoments)
 private:
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_mean_x();
  inline void clear_has_mean_x();
  inline void set_has_mean_y();
  inline void clear_has_mean_y();
  inline void set_has_moment_xx();
  inline void clear_has_moment_xx();
  inline void set_has_moment_xy();
  inline void clear_has_moment_xy();
  inline void set_has_moment_yy();
  inline void clear_has_moment_yy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float size_;
  float mean_x_;
  float mean_y_;
  float moment_xx_;
  float moment_xy_;
  float moment_yy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_segmentation_2eproto();
  friend void protobuf_AssignDesc_segmentation_2eproto();
  friend void protobuf_ShutdownFile_segmentation_2eproto();

  void InitAsDefaultInstance();
  static SegmentationDesc_ShapeMoments* default_instance_;
};
// -------------------------------------------------------------------

class SegmentationDesc_VectorMesh : public ::google::protobuf::Message {
 public:
  SegmentationDesc_VectorMesh();
  virtual ~SegmentationDesc_VectorMesh();

  SegmentationDesc_VectorMesh(const SegmentationDesc_VectorMesh& from);

  inline SegmentationDesc_VectorMesh& operator=(const SegmentationDesc_VectorMesh& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SegmentationDesc_VectorMesh& default_instance();

  void Swap(SegmentationDesc_VectorMesh* other);

  // implements Message ----------------------------------------------

  SegmentationDesc_VectorMesh* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SegmentationDesc_VectorMesh& from);
  void MergeFrom(const SegmentationDesc_VectorMesh& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float coord = 1 [packed = true];
  inline int coord_size() const;
  inline void clear_coord();
  static const int kCoordFieldNumber = 1;
  inline float coord(int index) const;
  inline void set_coord(int index, float value);
  inline void add_coord(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      coord() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_coord();

  // @@protoc_insertion_point(class_scope:segmentation.SegmentationDesc.VectorMesh)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< float > coord_;
  mutable int _coord_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_segmentation_2eproto();
  friend void protobuf_AssignDesc_segmentation_2eproto();
  friend void protobuf_ShutdownFile_segmentation_2eproto();

  void InitAsDefaultInstance();
  static SegmentationDesc_VectorMesh* default_instance_;
};
// -------------------------------------------------------------------

class SegmentationDesc_Polygon : public ::google::protobuf::Message {
 public:
  SegmentationDesc_Polygon();
  virtual ~SegmentationDesc_Polygon();

  SegmentationDesc_Polygon(const SegmentationDesc_Polygon& from);

  inline SegmentationDesc_Polygon& operator=(const SegmentationDesc_Polygon& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SegmentationDesc_Polygon& default_instance();

  void Swap(SegmentationDesc_Polygon* other);

  // implements Message ----------------------------------------------

  SegmentationDesc_Polygon* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SegmentationDesc_Polygon& from);
  void MergeFrom(const SegmentationDesc_Polygon& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 coord_idx = 1 [packed = true];
  inline int coord_idx_size() const;
  inline void clear_coord_idx();
  static const int kCoordIdxFieldNumber = 1;
  inline ::google::protobuf::int32 coord_idx(int index) const;
  inline void set_coord_idx(int index, ::google::protobuf::int32 value);
  inline void add_coord_idx(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      coord_idx() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_coord_idx();

  // optional bool hole = 2 [default = false];
  inline bool has_hole() const;
  inline void clear_hole();
  static const int kHoleFieldNumber = 2;
  inline bool hole() const;
  inline void set_hole(bool value);

  // @@protoc_insertion_point(class_scope:segmentation.SegmentationDesc.Polygon)
 private:
  inline void set_has_hole();
  inline void clear_has_hole();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > coord_idx_;
  mutable int _coord_idx_cached_byte_size_;
  bool hole_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_segmentation_2eproto();
  friend void protobuf_AssignDesc_segmentation_2eproto();
  friend void protobuf_ShutdownFile_segmentation_2eproto();

  void InitAsDefaultInstance();
  static SegmentationDesc_Polygon* default_instance_;
};
// -------------------------------------------------------------------

class SegmentationDesc_Vectorization : public ::google::protobuf::Message {
 public:
  SegmentationDesc_Vectorization();
  virtual ~SegmentationDesc_Vectorization();

  SegmentationDesc_Vectorization(const SegmentationDesc_Vectorization& from);

  inline SegmentationDesc_Vectorization& operator=(const SegmentationDesc_Vectorization& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SegmentationDesc_Vectorization& default_instance();

  void Swap(SegmentationDesc_Vectorization* other);

  // implements Message ----------------------------------------------

  SegmentationDesc_Vectorization* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SegmentationDesc_Vectorization& from);
  void MergeFrom(const SegmentationDesc_Vectorization& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .segmentation.SegmentationDesc.Polygon polygon = 1;
  inline int polygon_size() const;
  inline void clear_polygon();
  static const int kPolygonFieldNumber = 1;
  inline const ::segmentation::SegmentationDesc_Polygon& polygon(int index) const;
  inline ::segmentation::SegmentationDesc_Polygon* mutable_polygon(int index);
  inline ::segmentation::SegmentationDesc_Polygon* add_polygon();
  inline const ::google::protobuf::RepeatedPtrField< ::segmentation::SegmentationDesc_Polygon >&
      polygon() const;
  inline ::google::protobuf::RepeatedPtrField< ::segmentation::SegmentationDesc_Polygon >*
      mutable_polygon();

  // @@protoc_insertion_point(class_scope:segmentation.SegmentationDesc.Vectorization)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::segmentation::SegmentationDesc_Polygon > polygon_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_segmentation_2eproto();
  friend void protobuf_AssignDesc_segmentation_2eproto();
  friend void protobuf_ShutdownFile_segmentation_2eproto();

  void InitAsDefaultInstance();
  static SegmentationDesc_Vectorization* default_instance_;
};
// -------------------------------------------------------------------

class SegmentationDesc_Region2D : public ::google::protobuf::Message {
 public:
  SegmentationDesc_Region2D();
  virtual ~SegmentationDesc_Region2D();

  SegmentationDesc_Region2D(const SegmentationDesc_Region2D& from);

  inline SegmentationDesc_Region2D& operator=(const SegmentationDesc_Region2D& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SegmentationDesc_Region2D& default_instance();

  void Swap(SegmentationDesc_Region2D* other);

  // implements Message ----------------------------------------------

  SegmentationDesc_Region2D* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SegmentationDesc_Region2D& from);
  void MergeFrom(const SegmentationDesc_Region2D& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional .segmentation.SegmentationDesc.Rasterization raster = 3;
  inline bool has_raster() const;
  inline void clear_raster();
  static const int kRasterFieldNumber = 3;
  inline const ::segmentation::SegmentationDesc_Rasterization& raster() const;
  inline ::segmentation::SegmentationDesc_Rasterization* mutable_raster();
  inline ::segmentation::SegmentationDesc_Rasterization* release_raster();
  inline void set_allocated_raster(::segmentation::SegmentationDesc_Rasterization* raster);

  // optional .segmentation.SegmentationDesc.ShapeMoments shape_moments = 5;
  inline bool has_shape_moments() const;
  inline void clear_shape_moments();
  static const int kShapeMomentsFieldNumber = 5;
  inline const ::segmentation::SegmentationDesc_ShapeMoments& shape_moments() const;
  inline ::segmentation::SegmentationDesc_ShapeMoments* mutable_shape_moments();
  inline ::segmentation::SegmentationDesc_ShapeMoments* release_shape_moments();
  inline void set_allocated_shape_moments(::segmentation::SegmentationDesc_ShapeMoments* shape_moments);

  // optional .segmentation.SegmentationDesc.Vectorization vectorization = 6;
  inline bool has_vectorization() const;
  inline void clear_vectorization();
  static const int kVectorizationFieldNumber = 6;
  inline const ::segmentation::SegmentationDesc_Vectorization& vectorization() const;
  inline ::segmentation::SegmentationDesc_Vectorization* mutable_vectorization();
  inline ::segmentation::SegmentationDesc_Vectorization* release_vectorization();
  inline void set_allocated_vectorization(::segmentation::SegmentationDesc_Vectorization* vectorization);

  // @@protoc_insertion_point(class_scope:segmentation.SegmentationDesc.Region2D)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_raster();
  inline void clear_has_raster();
  inline void set_has_shape_moments();
  inline void clear_has_shape_moments();
  inline void set_has_vectorization();
  inline void clear_has_vectorization();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::segmentation::SegmentationDesc_Rasterization* raster_;
  ::segmentation::SegmentationDesc_ShapeMoments* shape_moments_;
  ::segmentation::SegmentationDesc_Vectorization* vectorization_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_segmentation_2eproto();
  friend void protobuf_AssignDesc_segmentation_2eproto();
  friend void protobuf_ShutdownFile_segmentation_2eproto();

  void InitAsDefaultInstance();
  static SegmentationDesc_Region2D* default_instance_;
};
// -------------------------------------------------------------------

class SegmentationDesc_CompoundRegion : public ::google::protobuf::Message {
 public:
  SegmentationDesc_CompoundRegion();
  virtual ~SegmentationDesc_CompoundRegion();

  SegmentationDesc_CompoundRegion(const SegmentationDesc_CompoundRegion& from);

  inline SegmentationDesc_CompoundRegion& operator=(const SegmentationDesc_CompoundRegion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SegmentationDesc_CompoundRegion& default_instance();

  void Swap(SegmentationDesc_CompoundRegion* other);

  // implements Message ----------------------------------------------

  SegmentationDesc_CompoundRegion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SegmentationDesc_CompoundRegion& from);
  void MergeFrom(const SegmentationDesc_CompoundRegion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // repeated int32 neighbor_id = 3;
  inline int neighbor_id_size() const;
  inline void clear_neighbor_id();
  static const int kNeighborIdFieldNumber = 3;
  inline ::google::protobuf::int32 neighbor_id(int index) const;
  inline void set_neighbor_id(int index, ::google::protobuf::int32 value);
  inline void add_neighbor_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      neighbor_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_neighbor_id();

  // optional int32 parent_id = 4 [default = -1];
  inline bool has_parent_id() const;
  inline void clear_parent_id();
  static const int kParentIdFieldNumber = 4;
  inline ::google::protobuf::int32 parent_id() const;
  inline void set_parent_id(::google::protobuf::int32 value);

  // repeated int32 child_id = 5;
  inline int child_id_size() const;
  inline void clear_child_id();
  static const int kChildIdFieldNumber = 5;
  inline ::google::protobuf::int32 child_id(int index) const;
  inline void set_child_id(int index, ::google::protobuf::int32 value);
  inline void add_child_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      child_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_child_id();

  // optional int32 start_frame = 6;
  inline bool has_start_frame() const;
  inline void clear_start_frame();
  static const int kStartFrameFieldNumber = 6;
  inline ::google::protobuf::int32 start_frame() const;
  inline void set_start_frame(::google::protobuf::int32 value);

  // optional int32 end_frame = 7;
  inline bool has_end_frame() const;
  inline void clear_end_frame();
  static const int kEndFrameFieldNumber = 7;
  inline ::google::protobuf::int32 end_frame() const;
  inline void set_end_frame(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:segmentation.SegmentationDesc.CompoundRegion)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_parent_id();
  inline void clear_has_parent_id();
  inline void set_has_start_frame();
  inline void clear_has_start_frame();
  inline void set_has_end_frame();
  inline void clear_has_end_frame();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > neighbor_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > child_id_;
  ::google::protobuf::int32 parent_id_;
  ::google::protobuf::int32 start_frame_;
  ::google::protobuf::int32 end_frame_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_segmentation_2eproto();
  friend void protobuf_AssignDesc_segmentation_2eproto();
  friend void protobuf_ShutdownFile_segmentation_2eproto();

  void InitAsDefaultInstance();
  static SegmentationDesc_CompoundRegion* default_instance_;
};
// -------------------------------------------------------------------

class SegmentationDesc_HierarchyLevel : public ::google::protobuf::Message {
 public:
  SegmentationDesc_HierarchyLevel();
  virtual ~SegmentationDesc_HierarchyLevel();

  SegmentationDesc_HierarchyLevel(const SegmentationDesc_HierarchyLevel& from);

  inline SegmentationDesc_HierarchyLevel& operator=(const SegmentationDesc_HierarchyLevel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SegmentationDesc_HierarchyLevel& default_instance();

  void Swap(SegmentationDesc_HierarchyLevel* other);

  // implements Message ----------------------------------------------

  SegmentationDesc_HierarchyLevel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SegmentationDesc_HierarchyLevel& from);
  void MergeFrom(const SegmentationDesc_HierarchyLevel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .segmentation.SegmentationDesc.CompoundRegion region = 2;
  inline int region_size() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 2;
  inline const ::segmentation::SegmentationDesc_CompoundRegion& region(int index) const;
  inline ::segmentation::SegmentationDesc_CompoundRegion* mutable_region(int index);
  inline ::segmentation::SegmentationDesc_CompoundRegion* add_region();
  inline const ::google::protobuf::RepeatedPtrField< ::segmentation::SegmentationDesc_CompoundRegion >&
      region() const;
  inline ::google::protobuf::RepeatedPtrField< ::segmentation::SegmentationDesc_CompoundRegion >*
      mutable_region();

  // @@protoc_insertion_point(class_scope:segmentation.SegmentationDesc.HierarchyLevel)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::segmentation::SegmentationDesc_CompoundRegion > region_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_segmentation_2eproto();
  friend void protobuf_AssignDesc_segmentation_2eproto();
  friend void protobuf_ShutdownFile_segmentation_2eproto();

  void InitAsDefaultInstance();
  static SegmentationDesc_HierarchyLevel* default_instance_;
};
// -------------------------------------------------------------------

class SegmentationDesc : public ::google::protobuf::Message {
 public:
  SegmentationDesc();
  virtual ~SegmentationDesc();

  SegmentationDesc(const SegmentationDesc& from);

  inline SegmentationDesc& operator=(const SegmentationDesc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SegmentationDesc& default_instance();

  void Swap(SegmentationDesc* other);

  // implements Message ----------------------------------------------

  SegmentationDesc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SegmentationDesc& from);
  void MergeFrom(const SegmentationDesc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SegmentationDesc_Rasterization Rasterization;
  typedef SegmentationDesc_ShapeMoments ShapeMoments;
  typedef SegmentationDesc_VectorMesh VectorMesh;
  typedef SegmentationDesc_Polygon Polygon;
  typedef SegmentationDesc_Vectorization Vectorization;
  typedef SegmentationDesc_Region2D Region2D;
  typedef SegmentationDesc_CompoundRegion CompoundRegion;
  typedef SegmentationDesc_HierarchyLevel HierarchyLevel;

  typedef SegmentationDesc_Connectedness Connectedness;
  static const Connectedness N4_CONNECT = SegmentationDesc_Connectedness_N4_CONNECT;
  static const Connectedness N8_CONNECT = SegmentationDesc_Connectedness_N8_CONNECT;
  static inline bool Connectedness_IsValid(int value) {
    return SegmentationDesc_Connectedness_IsValid(value);
  }
  static const Connectedness Connectedness_MIN =
    SegmentationDesc_Connectedness_Connectedness_MIN;
  static const Connectedness Connectedness_MAX =
    SegmentationDesc_Connectedness_Connectedness_MAX;
  static const int Connectedness_ARRAYSIZE =
    SegmentationDesc_Connectedness_Connectedness_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Connectedness_descriptor() {
    return SegmentationDesc_Connectedness_descriptor();
  }
  static inline const ::std::string& Connectedness_Name(Connectedness value) {
    return SegmentationDesc_Connectedness_Name(value);
  }
  static inline bool Connectedness_Parse(const ::std::string& name,
      Connectedness* value) {
    return SegmentationDesc_Connectedness_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .segmentation.SegmentationDesc.Region2D region = 2;
  inline int region_size() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 2;
  inline const ::segmentation::SegmentationDesc_Region2D& region(int index) const;
  inline ::segmentation::SegmentationDesc_Region2D* mutable_region(int index);
  inline ::segmentation::SegmentationDesc_Region2D* add_region();
  inline const ::google::protobuf::RepeatedPtrField< ::segmentation::SegmentationDesc_Region2D >&
      region() const;
  inline ::google::protobuf::RepeatedPtrField< ::segmentation::SegmentationDesc_Region2D >*
      mutable_region();

  // repeated .segmentation.SegmentationDesc.HierarchyLevel hierarchy = 3;
  inline int hierarchy_size() const;
  inline void clear_hierarchy();
  static const int kHierarchyFieldNumber = 3;
  inline const ::segmentation::SegmentationDesc_HierarchyLevel& hierarchy(int index) const;
  inline ::segmentation::SegmentationDesc_HierarchyLevel* mutable_hierarchy(int index);
  inline ::segmentation::SegmentationDesc_HierarchyLevel* add_hierarchy();
  inline const ::google::protobuf::RepeatedPtrField< ::segmentation::SegmentationDesc_HierarchyLevel >&
      hierarchy() const;
  inline ::google::protobuf::RepeatedPtrField< ::segmentation::SegmentationDesc_HierarchyLevel >*
      mutable_hierarchy();

  // optional int32 frame_width = 4 [default = 0];
  inline bool has_frame_width() const;
  inline void clear_frame_width();
  static const int kFrameWidthFieldNumber = 4;
  inline ::google::protobuf::int32 frame_width() const;
  inline void set_frame_width(::google::protobuf::int32 value);

  // optional int32 frame_height = 5 [default = 0];
  inline bool has_frame_height() const;
  inline void clear_frame_height();
  static const int kFrameHeightFieldNumber = 5;
  inline ::google::protobuf::int32 frame_height() const;
  inline void set_frame_height(::google::protobuf::int32 value);

  // optional int32 chunk_size = 6;
  inline bool has_chunk_size() const;
  inline void clear_chunk_size();
  static const int kChunkSizeFieldNumber = 6;
  inline ::google::protobuf::int32 chunk_size() const;
  inline void set_chunk_size(::google::protobuf::int32 value);

  // optional int32 overlap_start = 7;
  inline bool has_overlap_start() const;
  inline void clear_overlap_start();
  static const int kOverlapStartFieldNumber = 7;
  inline ::google::protobuf::int32 overlap_start() const;
  inline void set_overlap_start(::google::protobuf::int32 value);

  // optional int32 chunk_id = 8 [default = -1];
  inline bool has_chunk_id() const;
  inline void clear_chunk_id();
  static const int kChunkIdFieldNumber = 8;
  inline ::google::protobuf::int32 chunk_id() const;
  inline void set_chunk_id(::google::protobuf::int32 value);

  // optional int32 hierarchy_frame_idx = 9 [default = 0];
  inline bool has_hierarchy_frame_idx() const;
  inline void clear_hierarchy_frame_idx();
  static const int kHierarchyFrameIdxFieldNumber = 9;
  inline ::google::protobuf::int32 hierarchy_frame_idx() const;
  inline void set_hierarchy_frame_idx(::google::protobuf::int32 value);

  // repeated .segmentation.RegionFeatures features = 10;
  inline int features_size() const;
  inline void clear_features();
  static const int kFeaturesFieldNumber = 10;
  inline const ::segmentation::RegionFeatures& features(int index) const;
  inline ::segmentation::RegionFeatures* mutable_features(int index);
  inline ::segmentation::RegionFeatures* add_features();
  inline const ::google::protobuf::RepeatedPtrField< ::segmentation::RegionFeatures >&
      features() const;
  inline ::google::protobuf::RepeatedPtrField< ::segmentation::RegionFeatures >*
      mutable_features();

  // optional .segmentation.SegmentationDesc.VectorMesh vector_mesh = 11;
  inline bool has_vector_mesh() const;
  inline void clear_vector_mesh();
  static const int kVectorMeshFieldNumber = 11;
  inline const ::segmentation::SegmentationDesc_VectorMesh& vector_mesh() const;
  inline ::segmentation::SegmentationDesc_VectorMesh* mutable_vector_mesh();
  inline ::segmentation::SegmentationDesc_VectorMesh* release_vector_mesh();
  inline void set_allocated_vector_mesh(::segmentation::SegmentationDesc_VectorMesh* vector_mesh);

  // optional .segmentation.SegmentationDesc.Connectedness connectedness = 12 [default = N4_CONNECT];
  inline bool has_connectedness() const;
  inline void clear_connectedness();
  static const int kConnectednessFieldNumber = 12;
  inline ::segmentation::SegmentationDesc_Connectedness connectedness() const;
  inline void set_connectedness(::segmentation::SegmentationDesc_Connectedness value);

  // optional bool rasterization_removed = 13 [default = false];
  inline bool has_rasterization_removed() const;
  inline void clear_rasterization_removed();
  static const int kRasterizationRemovedFieldNumber = 13;
  inline bool rasterization_removed() const;
  inline void set_rasterization_removed(bool value);

  // @@protoc_insertion_point(class_scope:segmentation.SegmentationDesc)
 private:
  inline void set_has_frame_width();
  inline void clear_has_frame_width();
  inline void set_has_frame_height();
  inline void clear_has_frame_height();
  inline void set_has_chunk_size();
  inline void clear_has_chunk_size();
  inline void set_has_overlap_start();
  inline void clear_has_overlap_start();
  inline void set_has_chunk_id();
  inline void clear_has_chunk_id();
  inline void set_has_hierarchy_frame_idx();
  inline void clear_has_hierarchy_frame_idx();
  inline void set_has_vector_mesh();
  inline void clear_has_vector_mesh();
  inline void set_has_connectedness();
  inline void clear_has_connectedness();
  inline void set_has_rasterization_removed();
  inline void clear_has_rasterization_removed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::segmentation::SegmentationDesc_Region2D > region_;
  ::google::protobuf::RepeatedPtrField< ::segmentation::SegmentationDesc_HierarchyLevel > hierarchy_;
  ::google::protobuf::int32 frame_width_;
  ::google::protobuf::int32 frame_height_;
  ::google::protobuf::int32 chunk_size_;
  ::google::protobuf::int32 overlap_start_;
  ::google::protobuf::int32 chunk_id_;
  ::google::protobuf::int32 hierarchy_frame_idx_;
  ::google::protobuf::RepeatedPtrField< ::segmentation::RegionFeatures > features_;
  ::segmentation::SegmentationDesc_VectorMesh* vector_mesh_;
  int connectedness_;
  bool rasterization_removed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_segmentation_2eproto();
  friend void protobuf_AssignDesc_segmentation_2eproto();
  friend void protobuf_ShutdownFile_segmentation_2eproto();

  void InitAsDefaultInstance();
  static SegmentationDesc* default_instance_;
};
// -------------------------------------------------------------------

class AppearanceFeature : public ::google::protobuf::Message {
 public:
  AppearanceFeature();
  virtual ~AppearanceFeature();

  AppearanceFeature(const AppearanceFeature& from);

  inline AppearanceFeature& operator=(const AppearanceFeature& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppearanceFeature& default_instance();

  void Swap(AppearanceFeature* other);

  // implements Message ----------------------------------------------

  AppearanceFeature* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AppearanceFeature& from);
  void MergeFrom(const AppearanceFeature& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  static const int kAppearanceFieldNumber = 10;
  static ::google::protobuf::internal::ExtensionIdentifier< ::segmentation::RegionFeatures,
      ::google::protobuf::internal::MessageTypeTraits< ::segmentation::AppearanceFeature >, 11, false >
    appearance;
  // @@protoc_insertion_point(class_scope:segmentation.AppearanceFeature)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_segmentation_2eproto();
  friend void protobuf_AssignDesc_segmentation_2eproto();
  friend void protobuf_ShutdownFile_segmentation_2eproto();

  void InitAsDefaultInstance();
  static AppearanceFeature* default_instance_;
};
// -------------------------------------------------------------------

class FlowFeature : public ::google::protobuf::Message {
 public:
  FlowFeature();
  virtual ~FlowFeature();

  FlowFeature(const FlowFeature& from);

  inline FlowFeature& operator=(const FlowFeature& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FlowFeature& default_instance();

  void Swap(FlowFeature* other);

  // implements Message ----------------------------------------------

  FlowFeature* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlowFeature& from);
  void MergeFrom(const FlowFeature& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  static const int kFlowFieldNumber = 11;
  static ::google::protobuf::internal::ExtensionIdentifier< ::segmentation::RegionFeatures,
      ::google::protobuf::internal::MessageTypeTraits< ::segmentation::FlowFeature >, 11, false >
    flow;
  // @@protoc_insertion_point(class_scope:segmentation.FlowFeature)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_segmentation_2eproto();
  friend void protobuf_AssignDesc_segmentation_2eproto();
  friend void protobuf_ShutdownFile_segmentation_2eproto();

  void InitAsDefaultInstance();
  static FlowFeature* default_instance_;
};
// -------------------------------------------------------------------

class TextureFeature : public ::google::protobuf::Message {
 public:
  TextureFeature();
  virtual ~TextureFeature();

  TextureFeature(const TextureFeature& from);

  inline TextureFeature& operator=(const TextureFeature& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TextureFeature& default_instance();

  void Swap(TextureFeature* other);

  // implements Message ----------------------------------------------

  TextureFeature* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TextureFeature& from);
  void MergeFrom(const TextureFeature& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  static const int kTextureFieldNumber = 12;
  static ::google::protobuf::internal::ExtensionIdentifier< ::segmentation::RegionFeatures,
      ::google::protobuf::internal::MessageTypeTraits< ::segmentation::TextureFeature >, 11, false >
    texture;
  // @@protoc_insertion_point(class_scope:segmentation.TextureFeature)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_segmentation_2eproto();
  friend void protobuf_AssignDesc_segmentation_2eproto();
  friend void protobuf_ShutdownFile_segmentation_2eproto();

  void InitAsDefaultInstance();
  static TextureFeature* default_instance_;
};
// ===================================================================


// ===================================================================

// RegionFeatures

// required fixed32 id = 1;
inline bool RegionFeatures::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegionFeatures::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegionFeatures::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegionFeatures::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 RegionFeatures::id() const {
  return id_;
}
inline void RegionFeatures::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// SegmentationDesc_Rasterization_ScanInterval

// required int32 y = 1;
inline bool SegmentationDesc_Rasterization_ScanInterval::has_y() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SegmentationDesc_Rasterization_ScanInterval::set_has_y() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SegmentationDesc_Rasterization_ScanInterval::clear_has_y() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SegmentationDesc_Rasterization_ScanInterval::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 SegmentationDesc_Rasterization_ScanInterval::y() const {
  return y_;
}
inline void SegmentationDesc_Rasterization_ScanInterval::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// required int32 left_x = 2;
inline bool SegmentationDesc_Rasterization_ScanInterval::has_left_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SegmentationDesc_Rasterization_ScanInterval::set_has_left_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SegmentationDesc_Rasterization_ScanInterval::clear_has_left_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SegmentationDesc_Rasterization_ScanInterval::clear_left_x() {
  left_x_ = 0;
  clear_has_left_x();
}
inline ::google::protobuf::int32 SegmentationDesc_Rasterization_ScanInterval::left_x() const {
  return left_x_;
}
inline void SegmentationDesc_Rasterization_ScanInterval::set_left_x(::google::protobuf::int32 value) {
  set_has_left_x();
  left_x_ = value;
}

// required int32 right_x = 3;
inline bool SegmentationDesc_Rasterization_ScanInterval::has_right_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SegmentationDesc_Rasterization_ScanInterval::set_has_right_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SegmentationDesc_Rasterization_ScanInterval::clear_has_right_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SegmentationDesc_Rasterization_ScanInterval::clear_right_x() {
  right_x_ = 0;
  clear_has_right_x();
}
inline ::google::protobuf::int32 SegmentationDesc_Rasterization_ScanInterval::right_x() const {
  return right_x_;
}
inline void SegmentationDesc_Rasterization_ScanInterval::set_right_x(::google::protobuf::int32 value) {
  set_has_right_x();
  right_x_ = value;
}

// -------------------------------------------------------------------

// SegmentationDesc_Rasterization

// repeated .segmentation.SegmentationDesc.Rasterization.ScanInterval scan_inter = 1;
inline int SegmentationDesc_Rasterization::scan_inter_size() const {
  return scan_inter_.size();
}
inline void SegmentationDesc_Rasterization::clear_scan_inter() {
  scan_inter_.Clear();
}
inline const ::segmentation::SegmentationDesc_Rasterization_ScanInterval& SegmentationDesc_Rasterization::scan_inter(int index) const {
  return scan_inter_.Get(index);
}
inline ::segmentation::SegmentationDesc_Rasterization_ScanInterval* SegmentationDesc_Rasterization::mutable_scan_inter(int index) {
  return scan_inter_.Mutable(index);
}
inline ::segmentation::SegmentationDesc_Rasterization_ScanInterval* SegmentationDesc_Rasterization::add_scan_inter() {
  return scan_inter_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::segmentation::SegmentationDesc_Rasterization_ScanInterval >&
SegmentationDesc_Rasterization::scan_inter() const {
  return scan_inter_;
}
inline ::google::protobuf::RepeatedPtrField< ::segmentation::SegmentationDesc_Rasterization_ScanInterval >*
SegmentationDesc_Rasterization::mutable_scan_inter() {
  return &scan_inter_;
}

// -------------------------------------------------------------------

// SegmentationDesc_ShapeMoments

// optional float size = 1;
inline bool SegmentationDesc_ShapeMoments::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SegmentationDesc_ShapeMoments::set_has_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SegmentationDesc_ShapeMoments::clear_has_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SegmentationDesc_ShapeMoments::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline float SegmentationDesc_ShapeMoments::size() const {
  return size_;
}
inline void SegmentationDesc_ShapeMoments::set_size(float value) {
  set_has_size();
  size_ = value;
}

// optional float mean_x = 2;
inline bool SegmentationDesc_ShapeMoments::has_mean_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SegmentationDesc_ShapeMoments::set_has_mean_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SegmentationDesc_ShapeMoments::clear_has_mean_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SegmentationDesc_ShapeMoments::clear_mean_x() {
  mean_x_ = 0;
  clear_has_mean_x();
}
inline float SegmentationDesc_ShapeMoments::mean_x() const {
  return mean_x_;
}
inline void SegmentationDesc_ShapeMoments::set_mean_x(float value) {
  set_has_mean_x();
  mean_x_ = value;
}

// optional float mean_y = 3;
inline bool SegmentationDesc_ShapeMoments::has_mean_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SegmentationDesc_ShapeMoments::set_has_mean_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SegmentationDesc_ShapeMoments::clear_has_mean_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SegmentationDesc_ShapeMoments::clear_mean_y() {
  mean_y_ = 0;
  clear_has_mean_y();
}
inline float SegmentationDesc_ShapeMoments::mean_y() const {
  return mean_y_;
}
inline void SegmentationDesc_ShapeMoments::set_mean_y(float value) {
  set_has_mean_y();
  mean_y_ = value;
}

// optional float moment_xx = 4;
inline bool SegmentationDesc_ShapeMoments::has_moment_xx() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SegmentationDesc_ShapeMoments::set_has_moment_xx() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SegmentationDesc_ShapeMoments::clear_has_moment_xx() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SegmentationDesc_ShapeMoments::clear_moment_xx() {
  moment_xx_ = 0;
  clear_has_moment_xx();
}
inline float SegmentationDesc_ShapeMoments::moment_xx() const {
  return moment_xx_;
}
inline void SegmentationDesc_ShapeMoments::set_moment_xx(float value) {
  set_has_moment_xx();
  moment_xx_ = value;
}

// optional float moment_xy = 5;
inline bool SegmentationDesc_ShapeMoments::has_moment_xy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SegmentationDesc_ShapeMoments::set_has_moment_xy() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SegmentationDesc_ShapeMoments::clear_has_moment_xy() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SegmentationDesc_ShapeMoments::clear_moment_xy() {
  moment_xy_ = 0;
  clear_has_moment_xy();
}
inline float SegmentationDesc_ShapeMoments::moment_xy() const {
  return moment_xy_;
}
inline void SegmentationDesc_ShapeMoments::set_moment_xy(float value) {
  set_has_moment_xy();
  moment_xy_ = value;
}

// optional float moment_yy = 6;
inline bool SegmentationDesc_ShapeMoments::has_moment_yy() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SegmentationDesc_ShapeMoments::set_has_moment_yy() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SegmentationDesc_ShapeMoments::clear_has_moment_yy() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SegmentationDesc_ShapeMoments::clear_moment_yy() {
  moment_yy_ = 0;
  clear_has_moment_yy();
}
inline float SegmentationDesc_ShapeMoments::moment_yy() const {
  return moment_yy_;
}
inline void SegmentationDesc_ShapeMoments::set_moment_yy(float value) {
  set_has_moment_yy();
  moment_yy_ = value;
}

// -------------------------------------------------------------------

// SegmentationDesc_VectorMesh

// repeated float coord = 1 [packed = true];
inline int SegmentationDesc_VectorMesh::coord_size() const {
  return coord_.size();
}
inline void SegmentationDesc_VectorMesh::clear_coord() {
  coord_.Clear();
}
inline float SegmentationDesc_VectorMesh::coord(int index) const {
  return coord_.Get(index);
}
inline void SegmentationDesc_VectorMesh::set_coord(int index, float value) {
  coord_.Set(index, value);
}
inline void SegmentationDesc_VectorMesh::add_coord(float value) {
  coord_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
SegmentationDesc_VectorMesh::coord() const {
  return coord_;
}
inline ::google::protobuf::RepeatedField< float >*
SegmentationDesc_VectorMesh::mutable_coord() {
  return &coord_;
}

// -------------------------------------------------------------------

// SegmentationDesc_Polygon

// repeated int32 coord_idx = 1 [packed = true];
inline int SegmentationDesc_Polygon::coord_idx_size() const {
  return coord_idx_.size();
}
inline void SegmentationDesc_Polygon::clear_coord_idx() {
  coord_idx_.Clear();
}
inline ::google::protobuf::int32 SegmentationDesc_Polygon::coord_idx(int index) const {
  return coord_idx_.Get(index);
}
inline void SegmentationDesc_Polygon::set_coord_idx(int index, ::google::protobuf::int32 value) {
  coord_idx_.Set(index, value);
}
inline void SegmentationDesc_Polygon::add_coord_idx(::google::protobuf::int32 value) {
  coord_idx_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SegmentationDesc_Polygon::coord_idx() const {
  return coord_idx_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SegmentationDesc_Polygon::mutable_coord_idx() {
  return &coord_idx_;
}

// optional bool hole = 2 [default = false];
inline bool SegmentationDesc_Polygon::has_hole() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SegmentationDesc_Polygon::set_has_hole() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SegmentationDesc_Polygon::clear_has_hole() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SegmentationDesc_Polygon::clear_hole() {
  hole_ = false;
  clear_has_hole();
}
inline bool SegmentationDesc_Polygon::hole() const {
  return hole_;
}
inline void SegmentationDesc_Polygon::set_hole(bool value) {
  set_has_hole();
  hole_ = value;
}

// -------------------------------------------------------------------

// SegmentationDesc_Vectorization

// repeated .segmentation.SegmentationDesc.Polygon polygon = 1;
inline int SegmentationDesc_Vectorization::polygon_size() const {
  return polygon_.size();
}
inline void SegmentationDesc_Vectorization::clear_polygon() {
  polygon_.Clear();
}
inline const ::segmentation::SegmentationDesc_Polygon& SegmentationDesc_Vectorization::polygon(int index) const {
  return polygon_.Get(index);
}
inline ::segmentation::SegmentationDesc_Polygon* SegmentationDesc_Vectorization::mutable_polygon(int index) {
  return polygon_.Mutable(index);
}
inline ::segmentation::SegmentationDesc_Polygon* SegmentationDesc_Vectorization::add_polygon() {
  return polygon_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::segmentation::SegmentationDesc_Polygon >&
SegmentationDesc_Vectorization::polygon() const {
  return polygon_;
}
inline ::google::protobuf::RepeatedPtrField< ::segmentation::SegmentationDesc_Polygon >*
SegmentationDesc_Vectorization::mutable_polygon() {
  return &polygon_;
}

// -------------------------------------------------------------------

// SegmentationDesc_Region2D

// required int32 id = 1;
inline bool SegmentationDesc_Region2D::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SegmentationDesc_Region2D::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SegmentationDesc_Region2D::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SegmentationDesc_Region2D::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 SegmentationDesc_Region2D::id() const {
  return id_;
}
inline void SegmentationDesc_Region2D::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional .segmentation.SegmentationDesc.Rasterization raster = 3;
inline bool SegmentationDesc_Region2D::has_raster() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SegmentationDesc_Region2D::set_has_raster() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SegmentationDesc_Region2D::clear_has_raster() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SegmentationDesc_Region2D::clear_raster() {
  if (raster_ != NULL) raster_->::segmentation::SegmentationDesc_Rasterization::Clear();
  clear_has_raster();
}
inline const ::segmentation::SegmentationDesc_Rasterization& SegmentationDesc_Region2D::raster() const {
  return raster_ != NULL ? *raster_ : *default_instance_->raster_;
}
inline ::segmentation::SegmentationDesc_Rasterization* SegmentationDesc_Region2D::mutable_raster() {
  set_has_raster();
  if (raster_ == NULL) raster_ = new ::segmentation::SegmentationDesc_Rasterization;
  return raster_;
}
inline ::segmentation::SegmentationDesc_Rasterization* SegmentationDesc_Region2D::release_raster() {
  clear_has_raster();
  ::segmentation::SegmentationDesc_Rasterization* temp = raster_;
  raster_ = NULL;
  return temp;
}
inline void SegmentationDesc_Region2D::set_allocated_raster(::segmentation::SegmentationDesc_Rasterization* raster) {
  delete raster_;
  raster_ = raster;
  if (raster) {
    set_has_raster();
  } else {
    clear_has_raster();
  }
}

// optional .segmentation.SegmentationDesc.ShapeMoments shape_moments = 5;
inline bool SegmentationDesc_Region2D::has_shape_moments() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SegmentationDesc_Region2D::set_has_shape_moments() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SegmentationDesc_Region2D::clear_has_shape_moments() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SegmentationDesc_Region2D::clear_shape_moments() {
  if (shape_moments_ != NULL) shape_moments_->::segmentation::SegmentationDesc_ShapeMoments::Clear();
  clear_has_shape_moments();
}
inline const ::segmentation::SegmentationDesc_ShapeMoments& SegmentationDesc_Region2D::shape_moments() const {
  return shape_moments_ != NULL ? *shape_moments_ : *default_instance_->shape_moments_;
}
inline ::segmentation::SegmentationDesc_ShapeMoments* SegmentationDesc_Region2D::mutable_shape_moments() {
  set_has_shape_moments();
  if (shape_moments_ == NULL) shape_moments_ = new ::segmentation::SegmentationDesc_ShapeMoments;
  return shape_moments_;
}
inline ::segmentation::SegmentationDesc_ShapeMoments* SegmentationDesc_Region2D::release_shape_moments() {
  clear_has_shape_moments();
  ::segmentation::SegmentationDesc_ShapeMoments* temp = shape_moments_;
  shape_moments_ = NULL;
  return temp;
}
inline void SegmentationDesc_Region2D::set_allocated_shape_moments(::segmentation::SegmentationDesc_ShapeMoments* shape_moments) {
  delete shape_moments_;
  shape_moments_ = shape_moments;
  if (shape_moments) {
    set_has_shape_moments();
  } else {
    clear_has_shape_moments();
  }
}

// optional .segmentation.SegmentationDesc.Vectorization vectorization = 6;
inline bool SegmentationDesc_Region2D::has_vectorization() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SegmentationDesc_Region2D::set_has_vectorization() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SegmentationDesc_Region2D::clear_has_vectorization() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SegmentationDesc_Region2D::clear_vectorization() {
  if (vectorization_ != NULL) vectorization_->::segmentation::SegmentationDesc_Vectorization::Clear();
  clear_has_vectorization();
}
inline const ::segmentation::SegmentationDesc_Vectorization& SegmentationDesc_Region2D::vectorization() const {
  return vectorization_ != NULL ? *vectorization_ : *default_instance_->vectorization_;
}
inline ::segmentation::SegmentationDesc_Vectorization* SegmentationDesc_Region2D::mutable_vectorization() {
  set_has_vectorization();
  if (vectorization_ == NULL) vectorization_ = new ::segmentation::SegmentationDesc_Vectorization;
  return vectorization_;
}
inline ::segmentation::SegmentationDesc_Vectorization* SegmentationDesc_Region2D::release_vectorization() {
  clear_has_vectorization();
  ::segmentation::SegmentationDesc_Vectorization* temp = vectorization_;
  vectorization_ = NULL;
  return temp;
}
inline void SegmentationDesc_Region2D::set_allocated_vectorization(::segmentation::SegmentationDesc_Vectorization* vectorization) {
  delete vectorization_;
  vectorization_ = vectorization;
  if (vectorization) {
    set_has_vectorization();
  } else {
    clear_has_vectorization();
  }
}

// -------------------------------------------------------------------

// SegmentationDesc_CompoundRegion

// required int32 id = 1;
inline bool SegmentationDesc_CompoundRegion::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SegmentationDesc_CompoundRegion::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SegmentationDesc_CompoundRegion::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SegmentationDesc_CompoundRegion::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 SegmentationDesc_CompoundRegion::id() const {
  return id_;
}
inline void SegmentationDesc_CompoundRegion::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 size = 2;
inline bool SegmentationDesc_CompoundRegion::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SegmentationDesc_CompoundRegion::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SegmentationDesc_CompoundRegion::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SegmentationDesc_CompoundRegion::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 SegmentationDesc_CompoundRegion::size() const {
  return size_;
}
inline void SegmentationDesc_CompoundRegion::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// repeated int32 neighbor_id = 3;
inline int SegmentationDesc_CompoundRegion::neighbor_id_size() const {
  return neighbor_id_.size();
}
inline void SegmentationDesc_CompoundRegion::clear_neighbor_id() {
  neighbor_id_.Clear();
}
inline ::google::protobuf::int32 SegmentationDesc_CompoundRegion::neighbor_id(int index) const {
  return neighbor_id_.Get(index);
}
inline void SegmentationDesc_CompoundRegion::set_neighbor_id(int index, ::google::protobuf::int32 value) {
  neighbor_id_.Set(index, value);
}
inline void SegmentationDesc_CompoundRegion::add_neighbor_id(::google::protobuf::int32 value) {
  neighbor_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SegmentationDesc_CompoundRegion::neighbor_id() const {
  return neighbor_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SegmentationDesc_CompoundRegion::mutable_neighbor_id() {
  return &neighbor_id_;
}

// optional int32 parent_id = 4 [default = -1];
inline bool SegmentationDesc_CompoundRegion::has_parent_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SegmentationDesc_CompoundRegion::set_has_parent_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SegmentationDesc_CompoundRegion::clear_has_parent_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SegmentationDesc_CompoundRegion::clear_parent_id() {
  parent_id_ = -1;
  clear_has_parent_id();
}
inline ::google::protobuf::int32 SegmentationDesc_CompoundRegion::parent_id() const {
  return parent_id_;
}
inline void SegmentationDesc_CompoundRegion::set_parent_id(::google::protobuf::int32 value) {
  set_has_parent_id();
  parent_id_ = value;
}

// repeated int32 child_id = 5;
inline int SegmentationDesc_CompoundRegion::child_id_size() const {
  return child_id_.size();
}
inline void SegmentationDesc_CompoundRegion::clear_child_id() {
  child_id_.Clear();
}
inline ::google::protobuf::int32 SegmentationDesc_CompoundRegion::child_id(int index) const {
  return child_id_.Get(index);
}
inline void SegmentationDesc_CompoundRegion::set_child_id(int index, ::google::protobuf::int32 value) {
  child_id_.Set(index, value);
}
inline void SegmentationDesc_CompoundRegion::add_child_id(::google::protobuf::int32 value) {
  child_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SegmentationDesc_CompoundRegion::child_id() const {
  return child_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SegmentationDesc_CompoundRegion::mutable_child_id() {
  return &child_id_;
}

// optional int32 start_frame = 6;
inline bool SegmentationDesc_CompoundRegion::has_start_frame() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SegmentationDesc_CompoundRegion::set_has_start_frame() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SegmentationDesc_CompoundRegion::clear_has_start_frame() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SegmentationDesc_CompoundRegion::clear_start_frame() {
  start_frame_ = 0;
  clear_has_start_frame();
}
inline ::google::protobuf::int32 SegmentationDesc_CompoundRegion::start_frame() const {
  return start_frame_;
}
inline void SegmentationDesc_CompoundRegion::set_start_frame(::google::protobuf::int32 value) {
  set_has_start_frame();
  start_frame_ = value;
}

// optional int32 end_frame = 7;
inline bool SegmentationDesc_CompoundRegion::has_end_frame() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SegmentationDesc_CompoundRegion::set_has_end_frame() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SegmentationDesc_CompoundRegion::clear_has_end_frame() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SegmentationDesc_CompoundRegion::clear_end_frame() {
  end_frame_ = 0;
  clear_has_end_frame();
}
inline ::google::protobuf::int32 SegmentationDesc_CompoundRegion::end_frame() const {
  return end_frame_;
}
inline void SegmentationDesc_CompoundRegion::set_end_frame(::google::protobuf::int32 value) {
  set_has_end_frame();
  end_frame_ = value;
}

// -------------------------------------------------------------------

// SegmentationDesc_HierarchyLevel

// repeated .segmentation.SegmentationDesc.CompoundRegion region = 2;
inline int SegmentationDesc_HierarchyLevel::region_size() const {
  return region_.size();
}
inline void SegmentationDesc_HierarchyLevel::clear_region() {
  region_.Clear();
}
inline const ::segmentation::SegmentationDesc_CompoundRegion& SegmentationDesc_HierarchyLevel::region(int index) const {
  return region_.Get(index);
}
inline ::segmentation::SegmentationDesc_CompoundRegion* SegmentationDesc_HierarchyLevel::mutable_region(int index) {
  return region_.Mutable(index);
}
inline ::segmentation::SegmentationDesc_CompoundRegion* SegmentationDesc_HierarchyLevel::add_region() {
  return region_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::segmentation::SegmentationDesc_CompoundRegion >&
SegmentationDesc_HierarchyLevel::region() const {
  return region_;
}
inline ::google::protobuf::RepeatedPtrField< ::segmentation::SegmentationDesc_CompoundRegion >*
SegmentationDesc_HierarchyLevel::mutable_region() {
  return &region_;
}

// -------------------------------------------------------------------

// SegmentationDesc

// repeated .segmentation.SegmentationDesc.Region2D region = 2;
inline int SegmentationDesc::region_size() const {
  return region_.size();
}
inline void SegmentationDesc::clear_region() {
  region_.Clear();
}
inline const ::segmentation::SegmentationDesc_Region2D& SegmentationDesc::region(int index) const {
  return region_.Get(index);
}
inline ::segmentation::SegmentationDesc_Region2D* SegmentationDesc::mutable_region(int index) {
  return region_.Mutable(index);
}
inline ::segmentation::SegmentationDesc_Region2D* SegmentationDesc::add_region() {
  return region_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::segmentation::SegmentationDesc_Region2D >&
SegmentationDesc::region() const {
  return region_;
}
inline ::google::protobuf::RepeatedPtrField< ::segmentation::SegmentationDesc_Region2D >*
SegmentationDesc::mutable_region() {
  return &region_;
}

// repeated .segmentation.SegmentationDesc.HierarchyLevel hierarchy = 3;
inline int SegmentationDesc::hierarchy_size() const {
  return hierarchy_.size();
}
inline void SegmentationDesc::clear_hierarchy() {
  hierarchy_.Clear();
}
inline const ::segmentation::SegmentationDesc_HierarchyLevel& SegmentationDesc::hierarchy(int index) const {
  return hierarchy_.Get(index);
}
inline ::segmentation::SegmentationDesc_HierarchyLevel* SegmentationDesc::mutable_hierarchy(int index) {
  return hierarchy_.Mutable(index);
}
inline ::segmentation::SegmentationDesc_HierarchyLevel* SegmentationDesc::add_hierarchy() {
  return hierarchy_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::segmentation::SegmentationDesc_HierarchyLevel >&
SegmentationDesc::hierarchy() const {
  return hierarchy_;
}
inline ::google::protobuf::RepeatedPtrField< ::segmentation::SegmentationDesc_HierarchyLevel >*
SegmentationDesc::mutable_hierarchy() {
  return &hierarchy_;
}

// optional int32 frame_width = 4 [default = 0];
inline bool SegmentationDesc::has_frame_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SegmentationDesc::set_has_frame_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SegmentationDesc::clear_has_frame_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SegmentationDesc::clear_frame_width() {
  frame_width_ = 0;
  clear_has_frame_width();
}
inline ::google::protobuf::int32 SegmentationDesc::frame_width() const {
  return frame_width_;
}
inline void SegmentationDesc::set_frame_width(::google::protobuf::int32 value) {
  set_has_frame_width();
  frame_width_ = value;
}

// optional int32 frame_height = 5 [default = 0];
inline bool SegmentationDesc::has_frame_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SegmentationDesc::set_has_frame_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SegmentationDesc::clear_has_frame_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SegmentationDesc::clear_frame_height() {
  frame_height_ = 0;
  clear_has_frame_height();
}
inline ::google::protobuf::int32 SegmentationDesc::frame_height() const {
  return frame_height_;
}
inline void SegmentationDesc::set_frame_height(::google::protobuf::int32 value) {
  set_has_frame_height();
  frame_height_ = value;
}

// optional int32 chunk_size = 6;
inline bool SegmentationDesc::has_chunk_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SegmentationDesc::set_has_chunk_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SegmentationDesc::clear_has_chunk_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SegmentationDesc::clear_chunk_size() {
  chunk_size_ = 0;
  clear_has_chunk_size();
}
inline ::google::protobuf::int32 SegmentationDesc::chunk_size() const {
  return chunk_size_;
}
inline void SegmentationDesc::set_chunk_size(::google::protobuf::int32 value) {
  set_has_chunk_size();
  chunk_size_ = value;
}

// optional int32 overlap_start = 7;
inline bool SegmentationDesc::has_overlap_start() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SegmentationDesc::set_has_overlap_start() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SegmentationDesc::clear_has_overlap_start() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SegmentationDesc::clear_overlap_start() {
  overlap_start_ = 0;
  clear_has_overlap_start();
}
inline ::google::protobuf::int32 SegmentationDesc::overlap_start() const {
  return overlap_start_;
}
inline void SegmentationDesc::set_overlap_start(::google::protobuf::int32 value) {
  set_has_overlap_start();
  overlap_start_ = value;
}

// optional int32 chunk_id = 8 [default = -1];
inline bool SegmentationDesc::has_chunk_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SegmentationDesc::set_has_chunk_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SegmentationDesc::clear_has_chunk_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SegmentationDesc::clear_chunk_id() {
  chunk_id_ = -1;
  clear_has_chunk_id();
}
inline ::google::protobuf::int32 SegmentationDesc::chunk_id() const {
  return chunk_id_;
}
inline void SegmentationDesc::set_chunk_id(::google::protobuf::int32 value) {
  set_has_chunk_id();
  chunk_id_ = value;
}

// optional int32 hierarchy_frame_idx = 9 [default = 0];
inline bool SegmentationDesc::has_hierarchy_frame_idx() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SegmentationDesc::set_has_hierarchy_frame_idx() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SegmentationDesc::clear_has_hierarchy_frame_idx() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SegmentationDesc::clear_hierarchy_frame_idx() {
  hierarchy_frame_idx_ = 0;
  clear_has_hierarchy_frame_idx();
}
inline ::google::protobuf::int32 SegmentationDesc::hierarchy_frame_idx() const {
  return hierarchy_frame_idx_;
}
inline void SegmentationDesc::set_hierarchy_frame_idx(::google::protobuf::int32 value) {
  set_has_hierarchy_frame_idx();
  hierarchy_frame_idx_ = value;
}

// repeated .segmentation.RegionFeatures features = 10;
inline int SegmentationDesc::features_size() const {
  return features_.size();
}
inline void SegmentationDesc::clear_features() {
  features_.Clear();
}
inline const ::segmentation::RegionFeatures& SegmentationDesc::features(int index) const {
  return features_.Get(index);
}
inline ::segmentation::RegionFeatures* SegmentationDesc::mutable_features(int index) {
  return features_.Mutable(index);
}
inline ::segmentation::RegionFeatures* SegmentationDesc::add_features() {
  return features_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::segmentation::RegionFeatures >&
SegmentationDesc::features() const {
  return features_;
}
inline ::google::protobuf::RepeatedPtrField< ::segmentation::RegionFeatures >*
SegmentationDesc::mutable_features() {
  return &features_;
}

// optional .segmentation.SegmentationDesc.VectorMesh vector_mesh = 11;
inline bool SegmentationDesc::has_vector_mesh() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SegmentationDesc::set_has_vector_mesh() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SegmentationDesc::clear_has_vector_mesh() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SegmentationDesc::clear_vector_mesh() {
  if (vector_mesh_ != NULL) vector_mesh_->::segmentation::SegmentationDesc_VectorMesh::Clear();
  clear_has_vector_mesh();
}
inline const ::segmentation::SegmentationDesc_VectorMesh& SegmentationDesc::vector_mesh() const {
  return vector_mesh_ != NULL ? *vector_mesh_ : *default_instance_->vector_mesh_;
}
inline ::segmentation::SegmentationDesc_VectorMesh* SegmentationDesc::mutable_vector_mesh() {
  set_has_vector_mesh();
  if (vector_mesh_ == NULL) vector_mesh_ = new ::segmentation::SegmentationDesc_VectorMesh;
  return vector_mesh_;
}
inline ::segmentation::SegmentationDesc_VectorMesh* SegmentationDesc::release_vector_mesh() {
  clear_has_vector_mesh();
  ::segmentation::SegmentationDesc_VectorMesh* temp = vector_mesh_;
  vector_mesh_ = NULL;
  return temp;
}
inline void SegmentationDesc::set_allocated_vector_mesh(::segmentation::SegmentationDesc_VectorMesh* vector_mesh) {
  delete vector_mesh_;
  vector_mesh_ = vector_mesh;
  if (vector_mesh) {
    set_has_vector_mesh();
  } else {
    clear_has_vector_mesh();
  }
}

// optional .segmentation.SegmentationDesc.Connectedness connectedness = 12 [default = N4_CONNECT];
inline bool SegmentationDesc::has_connectedness() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SegmentationDesc::set_has_connectedness() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SegmentationDesc::clear_has_connectedness() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SegmentationDesc::clear_connectedness() {
  connectedness_ = 1;
  clear_has_connectedness();
}
inline ::segmentation::SegmentationDesc_Connectedness SegmentationDesc::connectedness() const {
  return static_cast< ::segmentation::SegmentationDesc_Connectedness >(connectedness_);
}
inline void SegmentationDesc::set_connectedness(::segmentation::SegmentationDesc_Connectedness value) {
  assert(::segmentation::SegmentationDesc_Connectedness_IsValid(value));
  set_has_connectedness();
  connectedness_ = value;
}

// optional bool rasterization_removed = 13 [default = false];
inline bool SegmentationDesc::has_rasterization_removed() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SegmentationDesc::set_has_rasterization_removed() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SegmentationDesc::clear_has_rasterization_removed() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SegmentationDesc::clear_rasterization_removed() {
  rasterization_removed_ = false;
  clear_has_rasterization_removed();
}
inline bool SegmentationDesc::rasterization_removed() const {
  return rasterization_removed_;
}
inline void SegmentationDesc::set_rasterization_removed(bool value) {
  set_has_rasterization_removed();
  rasterization_removed_ = value;
}

// -------------------------------------------------------------------

// AppearanceFeature

// -------------------------------------------------------------------

// FlowFeature

// -------------------------------------------------------------------

// TextureFeature


// @@protoc_insertion_point(namespace_scope)

}  // namespace segmentation

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::segmentation::SegmentationDesc_Connectedness>() {
  return ::segmentation::SegmentationDesc_Connectedness_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_segmentation_2eproto__INCLUDED
